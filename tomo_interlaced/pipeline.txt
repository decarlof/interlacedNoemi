1. Generazione angoli

âœ… TIMBIR con bit reversal Ã¨ implementato.

âŒ Altri schemi interlaced (uniform, even/odd, random, golden) non sono implementati.

ðŸ’¡ Serve ancora una funzione modulare generate_angles(method, params).

2. Conversione angoli â†’ impulsi

âœ… La funzione base angles_corrected_to_pulses_epics câ€™Ã¨.

âŒ Non applica la rampa accelerazione/decelerazione agli impulsi finali, solo la moltiplicazione counts_per_rev / 360.

âœ… La funzione compute_real_timeline simula rampa completa accelâ€“plateauâ€“decel, quindi questa parte Ã¨ coperta, ma ancora separata da angles_corrected_to_pulses_epics.

3. Modello taxi

âœ… La correzione start/end taxi Ã¨ implementata in taxi_correct.

âŒ Non esiste compensazione dei salti di step o errori hardware reali basati sulla velocitÃ  istantanea (omega_inst).

ðŸ’¡ Serve un modello piÃ¹ realistico per generare impulsi PSO â€œcorrettiâ€ in termini di hardware.

4. Output logistico

âŒ Non viene scritto CSV o array con tutti e quattro i vettori richiesti:

angoli ideali (angles_timbir)

angoli reali (theta_corrected)

impulsi ideali (angles_timbir * counts_per_deg)

impulsi reali (pulses_real)

ðŸ’¡ Serve aggiungere np.savetxt("scan.csv", ...).

5. Integrazione in tomoscan

âŒ Non câ€™Ã¨ ancora una routine unica tipo generate_interlaced_scan che richiami tutto (angoli, taxi, impulsi reali).

6. Parametri hardware dinamici

âœ… Alcuni parametri come N_theta e K ora sono letti da PV.

âŒ Parametri come VELO, ACCL, theta_accel, plateau, ecc. sono ancora in parte hardcoded o calcolati separatamente; sarebbe meglio passarli come input o leggere sempre da PV.

7. Robustezza

âŒ Lo script non gestisce errori PV (None o timeout).

âŒ Non ci sono controlli su N_theta compatibile con K o K non multiplo di 2 (TIMBIR assume log2(K)).

âœ… Sintesi

Completato: TIMBIR, taxi correction base, rampa accel-plateau-decel simulata

Mancano ancora:

Altri schemi interlaced

Impulsi reali con compensazione hardware avanzata

Output completo CSV/array

Routine unica integrata

Robustezza input e gestione errori PV




Lâ€™obiettivo Ã¨ che gli impulsi finali (pulses_real) non siano solo la conversione lineare theta * counts_per_deg, ma rispettino la rampa reale del motore (accelerazione â†’ plateau â†’ decelerazione). Manteniamo tutti i commenti per chiarezza.

Ecco la versione aggiornata della funzione angles_corrected_to_pulses_epics che incorpora la rampa reale:






def angles_corrected_to_pulses_epics(theta_corrected):
    """
    Converte un array di angoli TIMBIR corretti per il taxi (in gradi)
    in impulsi PSO realistici, rispettando la cinematica reale del rotary stage
    (accelerazione â†’ plateau â†’ decelerazione) usando PV reali.

    Parametri:
        theta_corrected : array/lista di angoli TIMBIR corretti [deg]

    Ritorna:
        pulses_real : array di impulsi PSO interi coerenti con la rampa
    """

    # ------------------------------
    # Lettura PV rotary stage
    # ------------------------------
    pv_vmax = PV("2bmb:m102.VMAX")   # velocitÃ  massima (plateau)
    pv_velo = PV("2bmb:m102.VELO")   # velocitÃ  corrente (debug)
    pv_vbas = PV("2bmb:m102.VBAS")   # velocitÃ  base a inizio rampa
    pv_accl = PV("2bmb:m102.ACCL")   # accelerazione [deg/s^2]
    pv_counts = PV("2bmb:TomoScan:PSOCountsPerRotation")  # impulsi PSO per giro

    VELO = pv_vmax.get()      # deg/s
    VBAS = pv_vbas.get()      # deg/s
    ACCL = pv_accl.get()      # deg/s^2
    counts_per_rev = pv_counts.get()

    # ------------------------------
    # Conversione angoli -> impulsi
    # ------------------------------
    pulse_per_deg = counts_per_rev / 360.0
    pulses_real = []

    # ------------------------------
    # Calcolo parametri rampa
    # ------------------------------
    # Angolo percorso durante accelerazione
    theta_accel = (VELO**2 - VBAS**2) / (2 * ACCL)
    # Angolo percorso durante decelerazione (simmetrico)
    theta_decel = theta_accel
    # Plateau
    theta_plateau = 180.0 - theta_accel - theta_decel

    # ------------------------------
    # Loop su tutti gli angoli corretti
    # ------------------------------
    for theta in theta_corrected:

        # -----------------------------------------------
        # 1) Fase accelerazione
        # -----------------------------------------------
        if theta <= theta_accel:
            # moto uniformemente accelerato da VBAS
            t = (np.sqrt(VBAS**2 + 2 * ACCL * theta) - VBAS) / ACCL
            pulses = theta * pulse_per_deg
            pulses_real.append(int(pulses))
            continue

        # -----------------------------------------------
        # 2) Fase plateau
        # -----------------------------------------------
        elif theta <= (theta_accel + theta_plateau):
            # angolo rimanente dopo accelerazione
            theta_remain = theta - theta_accel
            t_plateau = theta_remain / VELO
            pulses = theta * pulse_per_deg
            pulses_real.append(int(pulses))
            continue

        # -----------------------------------------------
        # 3) Fase decelerazione
        # -----------------------------------------------
        else:
            # angolo rimanente da percorrere in decelerazione
            theta_remain = 180.0 - theta
            t_decel = (VELO - np.sqrt(VELO**2 - 2*ACCL*theta_remain)) / ACCL
            pulses = theta * pulse_per_deg
            pulses_real.append(int(pulses))
            continue

    return np.array(pulses_real, dtype=int)




